<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jogo Hex com IA</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap');

        body {
            font-family: 'Orbitron', sans-serif;
        }
        svg .hex {
            fill: #1a1a2e;
            stroke: #00ffea;
            stroke-width: 1;
            transition: fill 0.3s, stroke 0.3s;
        }
        svg .hex:hover {
            fill: #162447;
            stroke: #ff00ff;
            filter: drop-shadow(0 0 5px #ff00ff);
        }
        svg .peca-ciano {
            fill: #00ffea;
            filter: drop-shadow(0 0 8px #00ffea);
        }
        svg .peca-magenta {
            fill: #ff00ff;
            filter: drop-shadow(0 0 8px #ff00ff);
        }
        svg .borda-ciano {
            fill: rgba(0, 255, 234, 0.4);
        }
        svg .borda-magenta {
            fill: rgba(255, 0, 255, 0.4);
        }
        .brilho-neon {
            box-shadow: 0 0 10px #00ffea, 0 0 20px #ff00ff;
        }
        .botao-neon:hover {
            box-shadow: 0 0 15px #ff00ff, 0 0 30px #00ffea;
        }
        .borda-neon {
            border: 1px solid #00ffea;
            box-shadow: 0 0 10px #00ffea;
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-100 min-h-screen flex flex-col items-center justify-center p-6 bg-[radial-gradient(circle_at_center,#1a1a2e_0%,#0a0a1e_100%)]">
    <header class="w-full max-w-6xl text-center mb-8">
        <h1 class="text-5xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-cyan-400 to-pink-500 tracking-wider animate-pulse">Jogo Hex: IA Cyberpunk</h1>
        <p class="text-gray-400 mt-3 text-lg">Desafie a IA Minimax em um tabuleiro hexagonal futurista</p>
    </header>
    <div class="container mx-auto flex flex-row gap-6 max-w-6xl h-[80vh]">
        <div class="w-1/4 p-6 bg-gray-900/90 rounded-2xl brilho-neon flex flex-col justify-between">
            <div>
                <h2 class="text-2xl font-bold mb-6 text-cyan-400 tracking-wide">Configurações</h2>
                <div class="space-y-6">
                    <div>
                        <label class="block text-sm font-medium mb-2 text-gray-300">Tamanho do Tabuleiro</label>
                        <select id="tamanho-tabuleiro" class="w-full p-3 bg-gray-900 border border-cyan-500 rounded-lg focus:ring-2 focus:ring-pink-500 text-gray-200 shadow-md transition-all">
                            <option value="5">5x5</option>
                            <option value="7">7x7</option>
                            <option value="9">9x9</option>
                            <option value="11" selected>11x11</option>
                            <option value="13">13x13</option>
                            <option value="19">19x19</option>
                        </select>
                    </div>
                    <div>
                        <label class="block text-sm font-medium mb-2 text-gray-300">Modo de Jogo</label>
                        <select id="modo-jogo" class="w-full p-3 bg-gray-900 border border-cyan-500 rounded-lg focus:ring-2 focus:ring-pink-500 text-gray-200 shadow-md transition-all">
                            <option value="jogador-vs-ia">Jogador vs IA</option>
                            <option value="ia-vs-ia">IA vs IA</option>
                        </select>
                    </div>
                    <div>
                        <label class="block text-sm font-medium mb-2 text-gray-300">Algoritmo da IA</label>
                        <select id="algoritmo-ia" class="w-full p-3 bg-gray-900 border border-cyan-500 rounded-lg focus:ring-2 focus:ring-pink-500 text-gray-200 shadow-md transition-all">
                            <option value="minimax">Minimax Puro</option>
                            <option value="alphabeta">Minimax com Alpha-Beta</option>
                        </select>
                    </div>
                    <div>
                        <label class="block text-sm font-medium mb-2 text-gray-300">Profundidade da IA</label>
                        <select id="profundidade-ia" class="w-full p-3 bg-gray-900 border border-cyan-500 rounded-lg focus:ring-2 focus:ring-pink-500 text-gray-200 shadow-md transition-all">
                            <option value="1">1</option>
                            <option value="2">2</option>
                            <option value="3" selected>3</option>
                            <option value="4">4</option>
                            <option value="5">5</option>
                        </select>
                    </div>
                    <div>
                        <label class="block text-sm font-medium mb-2 text-gray-300">Cor do Jogador (Jogador vs IA)</label>
                        <select id="cor-jogador" class="w-full p-3 bg-gray-900 border border-cyan-500 rounded-lg focus:ring-2 focus:ring-pink-500 text-gray-200 shadow-md transition-all">
                            <option value="1">Ciano (Esquerda-Direita)</option>
                            <option value="2">Magenta (Cima-Baixo)</option>
                        </select>
                    </div>
                </div>
            </div>
            <button id="iniciar-jogo" class="w-full bg-gradient-to-r from-cyan-500 to-pink-500 text-white p-3 rounded-lg botao-neon transition-all font-semibold mt-4">Iniciar Jogo</button>
        </div>
        <!-- Tabuleiro Principal -->
        <!-- Estratégia: Usa SVG para desenhar hexágonos dinamicamente, ajustando tamanhos para diferentes tabuleiros. -->
        <div class="w-2/4 flex justify-center items-center">
            <svg id="tabuleiro-hex" class="w-full h-full rounded-2xl bg-gray-900/80 backdrop-blur-md borda-neon"></svg>
        </div>
        <!-- Painel Direito: Informações do Jogo -->
        <!-- Estratégia: Exibe status, estatísticas e histórico para manter o usuário informado e engajado. -->
        <div class="w-1/4 p-6 bg-gray-900/90 rounded-2xl brilho-neon flex flex-col justify-between">
            <div>
                <h2 class="text-2xl font-bold mb-6 text-cyan-400 tracking-wide">Informações</h2>
                <div class="space-y-6">
                    <div class="p-6 bg-gray-900/90 rounded-lg borda-neon">
                        <h3 class="text-lg font-semibold text-cyan-400">Status</h3>
                        <p id="status" class="mt-3 text-gray-300 font-medium">Aguardando início...</p>
                    </div>
                    <div class="p-6 bg-gray-900/90 rounded-lg borda-neon">
                        <h3 class="text-lg font-semibold text-cyan-400">Estatísticas</h3>
                        <p id="estatisticas" class="mt-3 text-sm text-gray-400">Nós: 0<br>Tempo: 0ms</p>
                    </div>
                </div>
            </div>
            <div class="p-6 bg-gray-900/90 rounded-lg borda-neon">
                <h3 class="text-lg font-semibold text-cyan-400">Histórico de Jogadas</h3>
                <ul id="log-jogadas" class="mt-3 text-sm text-gray-400 list-disc pl-5 max-h-48 overflow-y-auto"></ul>
            </div>
        </div>
    </div>

    <script>
        /******************************************
         * ALGORITMO 1: UNION-FIND (UniaoBusca)
         * 
         * OBJETIVO: Detectar rapidamente quando um jogador conectou suas bordas opostas
         * 
         * COMO FUNCIONA:
         * 1. Cada célula começa sozinha em seu próprio conjunto
         * 2. Quando jogador coloca peça, ela se une aos vizinhos da mesma cor
         * 3. Usa "compressão de caminho" para manter operações rápidas
         * 4. Bordas virtuais nos extremos para verificar vitória
         ******************************************/

        class UniaoBusca {
            // 1
            constructor(tamanho) {
                // Cada célula começa como seu próprio conjunto
                this.pai = Array.from({ length: tamanho }, (_, i) => i);
                this.altura = new Array(tamanho).fill(0);
            }

            // 2 Buscar (encontra o representante do conjunto):
            buscar(x) {
                if (this.pai[x] !== x) {
                    this.pai[x] = this.buscar(this.pai[x]);
                }
                return this.pai[x];
            }

            // Une dois conjuntos usando união por altura
            // Estratégia: Une a árvore menor à maior para evitar árvores desbalanceadas, mantendo baixa complexidade.
            unir(x, y) {
                const raizX = this.buscar(x), raizY = this.buscar(y);
                if (raizX !== raizY) {
                    if (this.altura[raizX] > this.altura[raizY]) {
                        this.pai[raizY] = raizX;
                    } else if (this.altura[raizX] < this.altura[raizY]) {
                        this.pai[raizX] = raizY;
                    } else {
                        this.pai[raizY] = raizX;
                        this.altura[raizX]++;
                    }
                }
            }

            // Verifica se dois nós estão conectados
            conectado(x, y) {
                return this.buscar(x) === this.buscar(y);
            }

            // Cria uma cópia do Union-Find para simulações
            // Estratégia: Clonar permite simular jogadas sem alterar o estado original, essencial para o Minimax.
            clonar() {
                const copia = new UniaoBusca(this.pai.length);
                copia.pai = [...this.pai];
                copia.altura = [...this.altura];
                return copia;
            }
        }

        /******************************************
         * ALGORITMO 2: JOGO HEX COM IA
         * 
         * COMPONENTES PRINCIPAIS:
         * 1. Tabuleiro Hexagonal: Grid especial onde células têm 6 vizinhos
         * 2. Gerenciamento Estado: Controla jogadas, vez e vitória
         * 3. IA Minimax: Toma decisões simulando jogadas futuras
         * 4. Heurística: Avalia posições usando Dijkstra
         ******************************************/

        class JogoHex {
            constructor(tamanho) {
                this.tamanho = tamanho;
                this.tabuleiro = Array.from({ length: tamanho }, () => new Array(tamanho).fill(0));
                this.jogadorAtual = 1; // 1 = Ciano, 2 = Magenta
                this.uniaoCiano = new UniaoBusca(tamanho * tamanho + 2);
                this.uniaoMagenta = new UniaoBusca(tamanho * tamanho + 2);
                this.cianoEsquerda = tamanho * tamanho;
                this.cianoDireita = tamanho * tamanho + 1;
                this.magentaCima = tamanho * tamanho;
                this.magentaBaixo = tamanho * tamanho + 1;
                this.vencedor = 0;
                this.jogadas = [];
                this.nosExplorados = 0;
                this.tempoPensamento = 0;
            }

            // Converte coordenadas (linha, coluna) em índice único
            obterIndice(linha, coluna) {
                return linha * this.tamanho + coluna;
            }

            // Retorna vizinhos de uma célula hexagonal
            // Estratégia: O padrão hexagonal alterna offsets dependendo da paridade da linha, garantindo conectividade correta.
            obterVizinhos(linha, coluna) {
                const paridade = linha % 2;
                const deltas = paridade === 0
                    ? [[1, 0], [1, -1], [0, -1], [-1, -1], [-1, 0], [0, 1]]
                    : [[1, 1], [1, 0], [0, -1], [-1, 0], [-1, 1], [0, 1]];
                return deltas.map(([dl, dc]) => [linha + dl, coluna + dc])
                             .filter(([nl, nc]) => nl >= 0 && nl < this.tamanho && nc >= 0 && nc < this.tamanho);
            }

            // Coloca uma peça no tabuleiro e atualiza conexões
            // Estratégia: Atualiza o Union-Find para conectar células adjacentes e bordas virtuais, verificando vitória imediatamente.
            colocarPeca(linha, coluna, jogador) {
                if (this.tabuleiro[linha][coluna] !== 0 || this.vencedor !== 0) return false;
                this.tabuleiro[linha][coluna] = jogador;
                const indice = this.obterIndice(linha, coluna);
                const uniao = jogador === 1 ? this.uniaoCiano : this.uniaoMagenta;
                const inicioVirtual = jogador === 1 ? this.cianoEsquerda : this.magentaCima;
                const fimVirtual = jogador === 1 ? this.cianoDireita : this.magentaBaixo;

                this.obterVizinhos(linha, coluna).forEach(([nl, nc]) => {
                    if (this.tabuleiro[nl][nc] === jogador) {
                        uniao.unir(indice, this.obterIndice(nl, nc));
                    }
                });

                if (jogador === 1) {
                    if (coluna === 0) uniao.unir(indice, inicioVirtual);
                    if (coluna === this.tamanho - 1) uniao.unir(indice, fimVirtual);
                } else {
                    if (linha === 0) uniao.unir(indice, inicioVirtual);
                    if (linha === this.tamanho - 1) uniao.unir(indice, fimVirtual);
                }

                this.jogadas.push({ jogador, linha, coluna });
                this.verificarVitoria(jogador);
                this.jogadorAtual = 3 - jogador;
                return true;
            }

            // Verifica se o jogador venceu conectando suas bordas
            verificarVitoria(jogador) {
                const uniao = jogador === 1 ? this.uniaoCiano : this.uniaoMagenta;
                const inicioVirtual = jogador === 1 ? this.cianoEsquerda : this.magentaCima;
                const fimVirtual = jogador === 1 ? this.cianoDireita : this.magentaBaixo;
                if (uniao.conectado(inicioVirtual, fimVirtual)) {
                    this.vencedor = jogador;
                }
            }

            // Verifica se o jogo terminou
            ehTerminal() {
                return this.vencedor !== 0 || this.obterJogadasValidas().length === 0;
            }

            // Retorna todas as jogadas possíveis
            obterJogadasValidas() {
                const jogadas = [];
                for (let l = 0; l < this.tamanho; l++) {
                    for (let c = 0; c < this.tamanho; c++) {
                        if (this.tabuleiro[l][c] === 0) jogadas.push([l, c]);
                    }
                }
                return jogadas;
            }

            // Cria uma cópia do estado do jogo
            // Estratégia: Clonar o estado permite simular jogadas futuras sem alterar o tabuleiro real, essencial para a IA.
            clonar() {
                const copia = new JogoHex(this.tamanho);
                copia.tabuleiro = this.tabuleiro.map(linha => linha.slice());
                copia.jogadorAtual = this.jogadorAtual;
                copia.vencedor = this.vencedor;
                copia.jogadas = [...this.jogadas];
                copia.uniaoCiano = this.uniaoCiano.clonar();
                copia.uniaoMagenta = this.uniaoMagenta.clonar();
                return copia;
            }

            /******************************************
             * ALGORITMO 3: DIJKSTRA MODIFICADO
             * 
             * OBJETIVO: Calcular quão "fácil" é conectar as bordas
             * 
             * CUSTOS DE MOVIMENTO:
             * - Célula própria: 0 (caminho livre)
             * - Célula vazia: 1 (precisa de uma jogada)
             * - Célula adversária: Infinito (bloqueado)
             * 
             * USADO NA: Heurística para avaliar posições
             ******************************************/

            distanciaMenorCaminho(jogador) {
                // Define o tamanho do tabuleiro e total de nós (incluindo nós virtuais)
                const N = this.tamanho;
                const totalNos = N * N + 2;  
                const fonte = N * N;         // Nó virtual de início
                const destino = N * N + 1;   // Nó virtual de fim
                
                // Inicializa arrays para o algoritmo de Dijkstra
                const distancias = new Array(totalNos).fill(Infinity);  // Todas distâncias começam infinitas
                distancias[fonte] = 0;                                  // Distância da fonte para ela mesma é 0
                const visitado = new Array(totalNos).fill(false);       // Marca quais nós já foram visitados
                const eHorizontal = jogador === 1;                      // Define direção do caminho (horizontal=ciano, vertical=magenta)

                // Função que define o custo de movimento para cada tipo de célula
                const obterCusto = (jogadorCelula) => 
                    jogadorCelula === jogador ? 0 :     // Célula própria: custo 0
                    (jogadorCelula === 0 ? 1 : Infinity); // Célula vazia: custo 1, célula adversária: infinito

                // Define as bordas de início e fim baseado no jogador
                const bordaInicio = eHorizontal
                    ? Array.from({ length: N }, (_, l) => this.obterIndice(l, 0))     // Ciano: borda esquerda
                    : Array.from({ length: N }, (_, c) => this.obterIndice(0, c));    // Magenta: borda superior
                const bordaFim = eHorizontal
                    ? Array.from({ length: N }, (_, l) => this.obterIndice(l, N - 1)) // Ciano: borda direita
                    : Array.from({ length: N }, (_, c) => this.obterIndice(N - 1, c)); // Magenta: borda inferior

                // Loop principal do algoritmo de Dijkstra
                while (true) {
                    // Encontra o nó não visitado com menor distância
                    let menorDist = Infinity;
                    let u = -1;
                    for (let i = 0; i < totalNos; i++) {
                        if (!visitado[i] && distancias[i] < menorDist) {
                            menorDist = distancias[i];
                            u = i;
                        }
                    }
                    if (u === -1) break; // Se não encontrou nó, termina
                    visitado[u] = true;  // Marca nó como visitado

                    // Processa o nó atual baseado em seu tipo
                    if (u === fonte) {
                        // Se for a fonte, atualiza distâncias para todas as células da borda inicial
                        bordaInicio.forEach(idx => {
                            const custo = obterCusto(this.tabuleiro[Math.floor(idx / N)][idx % N]);
                            if (distancias[idx] > distancias[fonte] + custo) 
                                distancias[idx] = distancias[fonte] + custo;
                        });
                    } else if (u === destino) {
                        continue; // Ignora processamento do nó destino
                    } else {
                        // Para células normais do tabuleiro:
                        const linha = Math.floor(u / N);
                        const coluna = u % N;
                        // Processa todos os vizinhos da célula atual
                        this.obterVizinhos(linha, coluna).forEach(([nl, nc]) => {
                            const v = this.obterIndice(nl, nc);
                            const custo = obterCusto(this.tabuleiro[nl][nc]);
                            if (distancias[v] > distancias[u] + custo) 
                                distancias[v] = distancias[u] + custo;
                        });
                        // Se célula está na borda final, atualiza distância para o destino
                        if (bordaFim.includes(u)) {
                            if (distancias[destino] > distancias[u]) 
                                distancias[destino] = distancias[u];
                        }
                    }
                }

                // Retorna a distância mínima encontrada (ou N*N+1 se não houver caminho)
                return distancias[destino] === Infinity ? N * N + 1 : distancias[destino];
            }

            /******************************************
             * ALGORITMO 4: HEURÍSTICA DE AVALIAÇÃO
             * 
             * OBJETIVO: Dar uma "nota" para cada posição do tabuleiro
             * 
             * LÓGICA:
             * 1. Se vitória: ±10000 (valor extremo)
             * 2. Senão: distância_oponente - distância_própria
             *    - Quanto menor sua distância, melhor
             *    - Quanto maior a distância do oponente, melhor
             ******************************************/

            avaliar() {
                if (this.vencedor === 1) return 10000;
                if (this.vencedor === 2) return -10000;

                const distCiano = this.distanciaMenorCaminho(1);
                const distMagenta = this.distanciaMenorCaminho(2);

                return this.jogadorAtual === 1 ? distMagenta - distCiano : distCiano - distMagenta;
            }

            /******************************************
             * ALGORITMO 5: MINIMAX COM PODA ALPHA-BETA
             * 
             * OBJETIVO: Escolher a melhor jogada simulando o futuro
             * 
             * FUNCIONAMENTO:
             * 1. Simula todas as jogadas possíveis até profundidade X
             * 2. Alterna entre maximizar (IA) e minimizar (oponente)
             * 3. Usa poda alpha-beta para ignorar jogadas ruins
             * 4. Escolhe jogada com melhor avaliação heurística
             * 
             * OTIMIZAÇÃO:
             * - Alpha: melhor valor garantido para MAX
             * - Beta: melhor valor garantido para MIN
             * - Se alpha >= beta: pode podar (ignorar) este ramo
             ******************************************/

            /**
            * Função principal do algoritmo Minimax com Poda Alfa-Beta opcional.
            *
            * @param {number} profundidade - Quantos "níveis" (jogadas) à frente queremos olhar.
            * @param {boolean} maximizando - É a vez do jogador que quer a MAIOR pontuação (MAX)?
            * @param {number} alfa - O melhor valor (MAIOR) que o jogador MAX encontrou até agora em QUALQUER ramo.
            * @param {number} beta - O melhor valor (MENOR) que o jogador MIN encontrou até agora em QUALQUER ramo.
            * @param {boolean} usarPoda - Se 'true', ativa a Poda Alfa-Beta. Se 'false', é Minimax puro.
            */
            minimax(profundidade, maximizando, alfa, beta, usarPoda) {

                this.nosExplorados++;

                if (profundidade === 0 || this.ehTerminal()) {
                    // Se a recursão parou, apenas retornamos a "nota" deste tabuleiro.
                    // A função 'avaliar()' dá uma pontuação (ex: +10 se MAX ganhou, -10 se MIN ganhou, 0 se empate).
                    return this.avaliar();
                }

                let melhorValor;

                if (maximizando) {
                    melhorValor = -Infinity;
                } else {
                    melhorValor = Infinity;
                }


                // --- LOOP PRINCIPAL (EXPLORANDO OS "FILHOS") ---

                for (const [l, c] of this.obterJogadasValidas()) {

                    const filho = this.clonar();

                    filho.colocarPeca(l, c, filho.jogadorAtual);
                    const valor = filho.minimax(profundidade - 1, !maximizando, alfa, beta, usarPoda);
                    
                    
                    if (maximizando) {
                        melhorValor = Math.max(melhorValor, valor);
                        // --- LÓGICA DO ALFA (SÓ SE A PODA ESTIVER ATIVA) ---
                        if (usarPoda) {
                            alfa = Math.max(alfa, melhorValor);
                        }

                    } else { 

                        melhorValor = Math.min(melhorValor, valor);
                        
                        // --- LÓGICA DO BETA (SÓ SE A PODA ESTIVER ATIVA) ---
                        if (usarPoda) {
                            beta = Math.min(beta, melhorValor);
                        }
                    }
                    
                    // --- A PODA (O CORTE ALFA-BETA) ---
                    if (usarPoda && alfa >= beta) {
                        break; 
                    }
                } 
                return melhorValor;
            }

            // Escolhe o melhor movimento para a IA
            // Estratégia: Testa cada jogada possível e escolhe a que maximiza (ou minimiza) a pontuação, dependendo do jogador.
            obterMelhorJogada(algoritmo, profundidade) {
                this.nosExplorados = 0;
                const inicio = performance.now();
                let melhorValor = this.jogadorAtual === 1 ? -Infinity : Infinity;
                let melhorJogada = null;
                const usarPoda = algoritmo === 'alphabeta';

                for (const [l, c] of this.obterJogadasValidas()) {
                    const filho = this.clonar();
                    filho.colocarPeca(l, c, this.jogadorAtual);
                    const valor = filho.minimax(profundidade - 1, this.jogadorAtual !== 1, -Infinity, Infinity, usarPoda);
                    if (this.jogadorAtual === 1 ? valor > melhorValor : valor < melhorValor) {
                        melhorValor = valor;
                        melhorJogada = [l, c];
                    }
                }
                this.tempoPensamento = performance.now() - inicio;
                return melhorJogada;
            }
        }

        /******************************************
         * INTERFACE GRÁFICA E INTERAÇÃO
         * 
         * COMPONENTES:
         * 1. Tabuleiro SVG: Hexágonos e peças com efeito neon
         * 2. Painel Configuração: Tamanho, modo, algoritmo, profundidade
         * 3. Painel Informações: Status, estatísticas, histórico
         * 4. Eventos: Cliques do jogador e jogadas da IA
         ******************************************/

        // Variáveis globais para renderização
        // Estratégia: Ajusta dinamicamente o tamanho dos hexágonos com base no tamanho do tabuleiro para garantir boa visualização.
        let ladoHex = 30;
        let larguraHex = Math.sqrt(3) * ladoHex;
        let alturaHex = 2 * ladoHex;

        // Função de renderização do tabuleiro
        // Estratégia: Desenha hexágonos com SVG, usando cores neon (ciano e magenta) para reforçar o tema cyberpunk.
        function renderizarTabuleiro(jogo, svg) {
            ladoHex = Math.min(30, 700 / (jogo.tamanho * Math.sqrt(3)));
            larguraHex = Math.sqrt(3) * ladoHex;
            alturaHex = 2 * ladoHex;

            svg.innerHTML = '';
            const offsetX = larguraHex;
            const offsetY = alturaHex / 2;
            const larguraTotal = jogo.tamanho * larguraHex + larguraHex / 2 + offsetX * 2;
            const alturaTotal = jogo.tamanho * (alturaHex * 3 / 4) + alturaHex + offsetY * 2;
            svg.setAttribute('viewBox', `0 0 ${larguraTotal} ${alturaTotal}`);
            svg.setAttribute('width', '100%');
            svg.setAttribute('height', '100%');

            // Desenha bordas ciano (esquerda e direita)
            for (let l = 0; l < jogo.tamanho; l++) {
                const x = 0 + offsetX;
                const y = l * (alturaHex * 3 / 4) + offsetY + alturaHex / 2;
                const retangulo = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                retangulo.setAttribute('x', x - larguraHex / 2 - 15);
                retangulo.setAttribute('y', y - ladoHex);
                retangulo.setAttribute('width', 15);
                retangulo.setAttribute('height', alturaHex);
                retangulo.classList.add('borda-ciano');
                svg.appendChild(retangulo);
            }
            for (let l = 0; l < jogo.tamanho; l++) {
                const x = (jogo.tamanho - 1) * larguraHex + (l % 2 ? larguraHex / 2 : 0) + offsetX;
                const y = l * (alturaHex * 3 / 4) + offsetY + alturaHex / 2;
                const retangulo = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                retangulo.setAttribute('x', x + larguraHex / 2);
                retangulo.setAttribute('y', y - ladoHex);
                retangulo.setAttribute('width', 15);
                retangulo.setAttribute('height', alturaHex);
                retangulo.classList.add('borda-ciano');
                svg.appendChild(retangulo);
            }

            // Desenha bordas magenta (cima e baixo)
            for (let c = 0; c < jogo.tamanho; c++) {
                const x = c * larguraHex + offsetX;
                const y = offsetY;
                const retangulo = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                retangulo.setAttribute('x', x - larguraHex / 2);
                retangulo.setAttribute('y', y - ladoHex - 15);
                retangulo.setAttribute('width', larguraHex);
                retangulo.setAttribute('height', 15);
                retangulo.classList.add('borda-magenta');
                svg.appendChild(retangulo);
            }
            for (let c = 0; c < jogo.tamanho; c++) {
                const x = c * larguraHex + ((jogo.tamanho - 1) % 2 ? larguraHex / 2 : 0) + offsetX;
                const y = (jogo.tamanho - 1) * (alturaHex * 3 / 4) + offsetY + alturaHex / 2;
                const retangulo = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                retangulo.setAttribute('x', x - larguraHex / 2);
                retangulo.setAttribute('y', y + ladoHex);
                retangulo.setAttribute('width', larguraHex);
                retangulo.setAttribute('height', 15);
                retangulo.classList.add('borda-magenta');
                svg.appendChild(retangulo);
            }

            // Desenha hexágonos e peças
            for (let l = 0; l < jogo.tamanho; l++) {
                for (let c = 0; c < jogo.tamanho; c++) {
                    const x = c * larguraHex + (l % 2 ? larguraHex / 2 : 0) + offsetX;
                    const y = l * (alturaHex * 3 / 4) + offsetY + alturaHex / 2;
                    const pontos = [
                        [x, y - ladoHex],
                        [x + larguraHex / 2, y - ladoHex / 2],
                        [x + larguraHex / 2, y + ladoHex / 2],
                        [x, y + ladoHex],
                        [x - larguraHex / 2, y + ladoHex / 2],
                        [x - larguraHex / 2, y - ladoHex / 2]
                    ].map(p => p.join(',')).join(' ');
                    const hex = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                    hex.setAttribute('points', pontos);
                    hex.classList.add('hex');
                    hex.dataset.linha = l;
                    hex.dataset.coluna = c;
                    svg.appendChild(hex);

                    if (jogo.tabuleiro[l][c] !== 0) {
                        const circulo = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                        circulo.setAttribute('cx', x);
                        circulo.setAttribute('cy', y);
                        circulo.setAttribute('r', ladoHex * 0.7);
                        circulo.classList.add(jogo.tabuleiro[l][c] === 1 ? 'peca-ciano' : 'peca-magenta');
                        svg.appendChild(circulo);
                    }
                }
            }
        }

        // Configurações iniciais
        let jogo = null;
        let modo = 'jogador-vs-ia';
        let corJogador = 1;
        let algoritmoIA = 'minimax'; // Começa com 'minimax' = poda desligada
        let profundidadeIA = 3;

        // Evento de início do jogo
        // Estratégia: Reinicia o jogo com as configurações escolhidas, garantindo flexibilidade e controle do usuário.
        document.getElementById('iniciar-jogo').addEventListener('click', () => {
            const tamanho = parseInt(document.getElementById('tamanho-tabuleiro').value);
            modo = document.getElementById('modo-jogo').value;
            algoritmoIA = document.getElementById('algoritmo-ia').value;
            profundidadeIA = parseInt(document.getElementById('profundidade-ia').value);
            corJogador = parseInt(document.getElementById('cor-jogador').value);
            jogo = new JogoHex(tamanho);
            renderizarTabuleiro(jogo, document.getElementById('tabuleiro-hex'));
            document.getElementById('log-jogadas').innerHTML = '';
            document.getElementById('status').textContent = 'Vez atual: Ciano (Esquerda para Direita)';
            document.getElementById('estatisticas').textContent = 'Nós: 0\nTempo: 0ms';
            if (modo === 'ia-vs-ia' || (modo === 'jogador-vs-ia' && jogo.jogadorAtual !== corJogador)) {
                jogadaIA();
            }
        });

        // Evento de clique no tabuleiro
        // Estratégia: Permite ao jogador interagir diretamente com o tabuleiro, mas só em turnos válidos.
        document.getElementById('tabuleiro-hex').addEventListener('click', (e) => {
            if (!jogo || jogo.vencedor || (modo === 'jogador-vs-ia' && jogo.jogadorAtual !== corJogador)) return;
            const alvo = e.target;
            if (alvo.tagName.toLowerCase() === 'polygon') {
                const l = parseInt(alvo.dataset.linha);
                const c = parseInt(alvo.dataset.coluna);
                if (jogo.colocarPeca(l, c, jogo.jogadorAtual)) {
                    renderizarTabuleiro(jogo, document.getElementById('tabuleiro-hex'));
                    registrarJogada(jogo.jogadas.length, jogo.jogadas[jogo.jogadas.length - 1].jogador, l, c);
                    atualizarStatus();
                    if (jogo.vencedor) alert(`${jogo.vencedor === 1 ? 'Ciano' : 'Magenta'} venceu!`);
                    if (!jogo.vencedor && (modo === 'ia-vs-ia' || jogo.jogadorAtual !== corJogador)) {
                        jogadaIA();
                    }
                }
            }
        });

        // Executa a jogada da IA
        // Estratégia: Usa setTimeout para simular "pensamento", melhorando a experiência do usuário.
        function jogadaIA() {
            if (!jogo || jogo.vencedor) return;
            document.getElementById('status').textContent = 'IA está pensando...';
            setTimeout(() => {
                const [l, c] = jogo.obterMelhorJogada(algoritmoIA, profundidadeIA);
                jogo.colocarPeca(l, c, jogo.jogadorAtual);
                renderizarTabuleiro(jogo, document.getElementById('tabuleiro-hex'));
                registrarJogada(jogo.jogadas.length, jogo.jogadas[jogo.jogadas.length - 1].jogador, l, c);
                atualizarStatus();
                if (jogo.vencedor) alert(`${jogo.vencedor === 1 ? 'Ciano' : 'Magenta'} venceu!`);
                document.getElementById('estatisticas').textContent = `Nós: ${jogo.nosExplorados}\nTempo: ${jogo.tempoPensamento.toFixed(2)}ms`;
                if (modo === 'ia-vs-ia' && !jogo.vencedor) {
                    jogadaIA();
                }
            }, 100);
        }

        // Registra uma jogada no histórico
        // Estratégia: Mantém um log visível para o usuário acompanhar o progresso do jogo.
        function registrarJogada(numero, jogador, l, c) {
            const li = document.createElement('li');
            li.textContent = `#${numero}: ${jogador === 1 ? 'Ciano' : 'Magenta'} (${l},${c})`;
            document.getElementById('log-jogadas').appendChild(li);
        }

        // Atualiza o status do jogo
        // Estratégia: Informa ao usuário sobre o estado atual (vez ou vencedor), mantendo a interface clara.
        function atualizarStatus() {
            if (jogo.vencedor) {
                document.getElementById('status').textContent = `${jogo.vencedor === 1 ? 'Ciano' : 'Magenta'} venceu!`;
            } else {
                document.getElementById('status').textContent = `Vez atual: ${jogo.jogadorAtual === 1 ? 'Ciano (Esquerda para Direita)' : 'Magenta (Cima para Baixo)'}`;
            }
        }
    </script>
</body>
</html>