<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jogo Hex com IA</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap');

        body {
            font-family: 'Orbitron', sans-serif;
        }
        svg .hex {
            fill: #1a1a2e;
            stroke: #00ffea;
            stroke-width: 1;
            transition: fill 0.3s, stroke 0.3s;
        }
        svg .hex:hover {
            fill: #162447;
            stroke: #ff00ff;
            filter: drop-shadow(0 0 5px #ff00ff);
        }
        svg .blue-piece {
            fill: #00ffea;
            filter: drop-shadow(0 0 8px #00ffea);
        }
        svg .red-piece {
            fill: #ff00ff;
            filter: drop-shadow(0 0 8px #ff00ff);
        }
        svg .border-blue {
            fill: rgba(0, 255, 234, 0.4);
        }
        svg .border-red {
            fill: rgba(255, 0, 255, 0.4);
        }
        .neon-glow {
            box-shadow: 0 0 10px #00ffea, 0 0 20px #ff00ff;
        }
        .neon-button:hover {
            box-shadow: 0 0 15px #ff00ff, 0 0 30px #00ffea;
        }
        .neon-border {
            border: 1px solid #00ffea;
            box-shadow: 0 0 10px #00ffea;
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-100 min-h-screen flex flex-col items-center justify-center p-6 bg-[radial-gradient(circle_at_center,#1a1a2e_0%,#0a0a1e_100%)]">
    <header class="w-full max-w-6xl text-center mb-8">
        <h1 class="text-5xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-cyan-400 to-pink-500 tracking-wider animate-pulse">Jogo Hex: IA Cyberpunk</h1>
        <p class="text-gray-400 mt-3 text-lg">Desafie a IA Minimax em um tabuleiro hexagonal futurista</p>
    </header>
    <div class="container mx-auto flex flex-row gap-6 max-w-6xl h-[80vh]">
        <!-- Left Sidebar: Game Settings -->
        <div class="w-1/4 p-6 bg-gray-900/90 rounded-2xl neon-glow flex flex-col justify-between">
            <div>
                <h2 class="text-2xl font-bold mb-6 text-cyan-400 tracking-wide">Configurações</h2>
                <div class="space-y-6">
                    <div>
                        <label class="block text-sm font-medium mb-2 text-gray-300">Tamanho do Tabuleiro</label>
                        <select id="board-size" class="w-full p-3 bg-gray-900 border border-cyan-500 rounded-lg focus:ring-2 focus:ring-pink-500 text-gray-200 shadow-md transition-all">
                            <option value="5">5x5</option>
                            <option value="7">7x7</option>
                            <option value="9">9x9</option>
                            <option value="11" selected>11x11</option>
                            <option value="13">13x13</option>
                            <option value="19">19x19</option>
                        </select>
                    </div>
                    <div>
                        <label class="block text-sm font-medium mb-2 text-gray-300">Modo de Jogo</label>
                        <select id="game-mode" class="w-full p-3 bg-gray-900 border border-cyan-500 rounded-lg focus:ring-2 focus:ring-pink-500 text-gray-200 shadow-md transition-all">
                            <option value="pva">Jogador vs IA</option>
                            <option value="ava">IA vs IA</option>
                        </select>
                    </div>
                    <div>
                        <label class="block text-sm font-medium mb-2 text-gray-300">Algoritmo da IA</label>
                        <select id="ai-algo" class="w-full p-3 bg-gray-900 border border-cyan-500 rounded-lg focus:ring-2 focus:ring-pink-500 text-gray-200 shadow-md transition-all">
                            <option value="minimax">Minimax Puro</option>
                            <option value="alphabeta">Minimax com Alpha-Beta</option>
                        </select>
                    </div>
                    <div>
                        <label class="block text-sm font-medium mb-2 text-gray-300">Profundidade da IA</label>
                        <select id="ai-depth" class="w-full p-3 bg-gray-900 border border-cyan-500 rounded-lg focus:ring-2 focus:ring-pink-500 text-gray-200 shadow-md transition-all">
                            <option value="1">1</option>
                            <option value="2">2</option>
                            <option value="3" selected>3</option>
                            <option value="4">4</option>
                            <option value="5">5</option>
                        </select>
                    </div>
                    <div>
                        <label class="block text-sm font-medium mb-2 text-gray-300">Cor do Jogador (Jogador vs IA)</label>
                        <select id="player-color" class="w-full p-3 bg-gray-900 border border-cyan-500 rounded-lg focus:ring-2 focus:ring-pink-500 text-gray-200 shadow-md transition-all">
                            <option value="1">Ciano (Esquerda-Direita)</option>
                            <option value="2">Magenta (Cima-Baixo)</option>
                        </select>
                    </div>
                </div>
            </div>
            <button id="start-game" class="w-full bg-gradient-to-r from-cyan-500 to-pink-500 text-white p-3 rounded-lg neon-button transition-all font-semibold mt-4">Iniciar Jogo</button>
        </div>
        <!-- Main Board -->
        <div class="w-2/4 flex justify-center items-center">
            <svg id="hex-board" class="w-full h-full rounded-2xl bg-gray-900/80 backdrop-blur-md neon-border"></svg>
        </div>
        <!-- Right Sidebar: Game Status -->
        <div class="w-1/4 p-6 bg-gray-900/90 rounded-2xl neon-glow flex flex-col justify-between">
            <div>
                <h2 class="text-2xl font-bold mb-6 text-cyan-400 tracking-wide">Informações</h2>
                <div class="space-y-6">
                    <div class="p-6 bg-gray-900/90 rounded-lg neon-border">
                        <h3 class="text-lg font-semibold text-cyan-400">Status</h3>
                        <p id="status" class="mt-3 text-gray-300 font-medium">Aguardando início...</p>
                    </div>
                    <div class="p-6 bg-gray-900/90 rounded-lg neon-border">
                        <h3 class="text-lg font-semibold text-cyan-400">Estatísticas</h3>
                        <p id="stats" class="mt-3 text-sm text-gray-400">Nós: 0<br>Tempo: 0ms</p>
                    </div>
                </div>
            </div>
            <div class="p-6 bg-gray-900/90 rounded-lg neon-border">
                <h3 class="text-lg font-semibold text-cyan-400">Histórico de Jogadas</h3>
                <ul id="move-log" class="mt-3 text-sm text-gray-400 list-disc pl-5 max-h-48 overflow-y-auto"></ul>
            </div>
        </div>
    </div>

    <script>
        class UnionFind {
            constructor(size) {
                this.parent = Array.from({ length: size }, (_, i) => i);
                this.rank = new Array(size).fill(0);
            }
            find(x) {
                if (this.parent[x] !== x) {
                    this.parent[x] = this.find(this.parent[x]);
                }
                return this.parent[x];
            }
            union(x, y) {
                const rx = this.find(x), ry = this.find(y);
                if (rx !== ry) {
                    if (this.rank[rx] > this.rank[ry]) {
                        this.parent[ry] = rx;
                    } else if (this.rank[rx] < this.rank[ry]) {
                        this.parent[rx] = ry;
                    } else {
                        this.parent[ry] = rx;
                        this.rank[rx]++;
                    }
                }
            }
            connected(x, y) {
                return this.find(x) === this.find(y);
            }
            clone() {
                const c = new UnionFind(this.parent.length);
                c.parent = [...this.parent];
                c.rank = [...this.rank];
                return c;
            }
        }

        class HexGame {
            constructor(size) {
                this.size = size;
                this.board = Array.from({ length: size }, () => new Array(size).fill(0));
                this.currentPlayer = 1;
                this.blueUF = new UnionFind(size * size + 2);
                this.redUF = new UnionFind(size * size + 2);
                this.blueLeft = size * size;
                this.blueRight = size * size + 1;
                this.redTop = size * size;
                this.redBottom = size * size + 1;
                this.winner = 0;
                this.moves = [];
                this.nodesExplored = 0;
                this.thinkingTime = 0;
            }

            getIndex(row, col) {
                return row * this.size + col;
            }

            getNeighbors(row, col) {
                const parity = row % 2;
                const deltas = parity === 0
                    ? [[1, 0], [1, -1], [0, -1], [-1, -1], [-1, 0], [0, 1]]
                    : [[1, 1], [1, 0], [0, -1], [-1, 0], [-1, 1], [0, 1]];
                return deltas.map(([dr, dc]) => [row + dr, col + dc])
                            .filter(([nr, nc]) => nr >= 0 && nr < this.size && nc >= 0 && nc < this.size);
            }

            placePiece(row, col, player) {
                if (this.board[row][col] !== 0 || this.winner !== 0) return false;
                this.board[row][col] = player;
                const idx = this.getIndex(row, col);
                const uf = player === 1 ? this.blueUF : this.redUF;
                const virtualStart = player === 1 ? this.blueLeft : this.redTop;
                const virtualEnd = player === 1 ? this.blueRight : this.redBottom;
                this.getNeighbors(row, col).forEach(([nr, nc]) => {
                    if (this.board[nr][nc] === player) {
                        uf.union(idx, this.getIndex(nr, nc));
                    }
                });
                if (player === 1) {
                    if (col === 0) uf.union(idx, virtualStart);
                    if (col === this.size - 1) uf.union(idx, virtualEnd);
                } else {
                    if (row === 0) uf.union(idx, virtualStart);
                    if (row === this.size - 1) uf.union(idx, virtualEnd);
                }
                this.moves.push({ player, row, col });
                this.checkWin(player);
                this.currentPlayer = 3 - player;
                return true;
            }

            checkWin(player) {
                const uf = player === 1 ? this.blueUF : this.redUF;
                const virtualStart = player === 1 ? this.blueLeft : this.redTop;
                const virtualEnd = player === 1 ? this.blueRight : this.redBottom;
                if (uf.connected(virtualStart, virtualEnd)) {
                    this.winner = player;
                }
            }

            isTerminal() {
                return this.winner !== 0 || this.getValidMoves().length === 0;
            }

            getValidMoves() {
                const moves = [];
                for (let r = 0; r < this.size; r++) {
                    for (let c = 0; c < this.size; c++) {
                        if (this.board[r][c] === 0) moves.push([r, c]);
                    }
                }
                return moves;
            }

            clone() {
                const clone = new HexGame(this.size);
                clone.board = this.board.map(row => row.slice());
                clone.currentPlayer = this.currentPlayer;
                clone.winner = this.winner;
                clone.moves = [...this.moves];
                clone.blueUF = this.blueUF.clone();
                clone.redUF = this.redUF.clone();
                return clone;
            }

            shortestPathDist(player) {
                const N = this.size;
                const totalNodes = N * N + 2;
                const S = N * N;
                const G = N * N + 1;
                const dist = new Array(totalNodes).fill(Infinity);
                dist[S] = 0;
                const visited = new Array(totalNodes).fill(false);
                const isHorizontal = player === 1;

                const getCost = (cellPlayer) => cellPlayer === player ? 0 : (cellPlayer === 0 ? 1 : Infinity);

                const startBorder = isHorizontal ? Array.from({ length: N }, (_, r) => this.getIndex(r, 0)) : Array.from({ length: N }, (_, c) => this.getIndex(0, c));
                const endBorder = isHorizontal ? Array.from({ length: N }, (_, r) => this.getIndex(r, N-1)) : Array.from({ length: N }, (_, c) => this.getIndex(N-1, c));

                while (true) {
                    let minDist = Infinity;
                    let u = -1;
                    for (let i = 0; i < totalNodes; i++) {
                        if (!visited[i] && dist[i] < minDist) {
                            minDist = dist[i];
                            u = i;
                        }
                    }
                    if (u === -1) break;
                    visited[u] = true;

                    if (u === S) {
                        startBorder.forEach(idx => {
                            const cost = getCost(this.board[Math.floor(idx / N)][idx % N]);
                            if (dist[idx] > dist[S] + cost) dist[idx] = dist[S] + cost;
                        });
                    } else if (u === G) {
                        continue;
                    } else {
                        const row = Math.floor(u / N);
                        const col = u % N;
                        this.getNeighbors(row, col).forEach(([nr, nc]) => {
                            const v = this.getIndex(nr, nc);
                            const cost = getCost(this.board[nr][nc]);
                            if (dist[v] > dist[u] + cost) dist[v] = dist[u] + cost;
                        });
                        if (endBorder.includes(u)) {
                            if (dist[G] > dist[u]) dist[G] = dist[u];
                        }
                    }
                }

                return dist[G] === Infinity ? N * N + 1 : dist[G];
            }

            // HEURÍSTICA: Avalia o tabuleiro calculando a distância do menor caminho para cada jogador conectar seus lados respectivos.
            // A heurística retorna uma pontuação baseada na diferença entre a distância do oponente e a distância do jogador,
            // favorecendo caminhos mais curtos para o jogador atual. Isso guia o algoritmo de busca em direção a movimentos vantajosos.
            // Se um jogador já venceu, retorna um valor extremamente alto (10000 para vitória) ou baixo (-10000 para derrota).
            
            evaluate() {
                if (this.winner === 1) return 10000;
                if (this.winner === 2) return -10000;
                const blueDist = this.shortestPathDist(1);
                const redDist = this.shortestPathDist(2);
                return this.currentPlayer === 1 ? redDist - blueDist : blueDist - redDist;
            }

            // ALGORITMO MINIMAX COM PODA ALPHA-BETA:
            // Este algoritmo implementa uma busca adversarial em árvore de jogo com dois componentes principais:
            // 
            // 1. MINIMAX: Explora recursivamente todos os movimentos possíveis até uma profundidade máxima (depth).
            //    - Alterna entre maximizar (isMax = true) e minimizar (isMax = false) para simular os turnos dos dois jogadores.
            //    - Para o jogador atual (maximizador), busca o movimento que resulta no melhor valor.
            //    - Para o oponente (minimizador), busca o movimento que resulta no pior valor para nós.
            //    - Quando depth = 0 ou o jogo termina, avalia o estado atual usando a heurística.
            //
            // 2. PODA ALPHA-BETA (quando useAB = true): Otimiza o Minimax eliminando ramos desnecessários.
            //    - alpha: melhor valor que o maximizador pode garantir.
            //    - beta: melhor valor que o minimizador pode garantir.
            //    - Se alpha >= beta em qualquer ponto, o ramo é podado (não precisa ser explorado).
            //    - Reduz dramaticamente o número de nós explorados, especialmente em profundidades maiores.
            //
            // Parâmetros:
            //   - depth: profundidade restante de busca (diminui a cada recursão).
            //   - isMax: true se é a vez de maximizar, false se é a vez de minimizar.
            //   - alpha: valor alfa para poda (apenas quando useAB = true).
            //   - beta: valor beta para poda (apenas quando useAB = true).
            //   - useAB: true para ativar poda alpha-beta, false para minimax puro.
            //
            // Retorna: Valor da posição atual (score da heurística ou resultado recursivo).

            minimax(depth, isMax, alpha, beta, useAB) {
                this.nodesExplored++;
                if (depth === 0 || this.isTerminal()) return this.evaluate();
                let best = isMax ? -Infinity : Infinity;
                const moves = this.getValidMoves();
                for (const [r, c] of moves) {
                    const child = this.clone();
                    child.placePiece(r, c, child.currentPlayer);
                    const val = child.minimax(depth - 1, !isMax, alpha, beta, useAB);
                    if (isMax) {
                        best = Math.max(best, val);
                        if (useAB) alpha = Math.max(alpha, best);
                    } else {
                        best = Math.min(best, val);
                        if (useAB) beta = Math.min(beta, best);
                    }
                    if (useAB && alpha >= beta) break;
                }
                return best;
            }

            getBestMove(algo, depth) {
                this.nodesExplored = 0;
                const startTime = performance.now();
                let bestVal = this.currentPlayer === 1 ? -Infinity : Infinity;
                let bestMove = null;
                const useAB = algo === 'alphabeta';
                const moves = this.getValidMoves();
                for (const [r, c] of moves) {
                    const child = this.clone();
                    child.placePiece(r, c, this.currentPlayer);
                    const val = child.minimax(depth - 1, this.currentPlayer !== 1, -Infinity, Infinity, useAB);
                    if (this.currentPlayer === 1 ? val > bestVal : val < bestVal) {
                        bestVal = val;
                        bestMove = [r, c];
                    }
                }
                this.thinkingTime = performance.now() - startTime;
                return bestMove;
            }
        }

        let hexSide = 30;
        let hexWidth = Math.sqrt(3) * hexSide;
        let hexHeight = 2 * hexSide;

        function renderBoard(game, svg) {
            hexSide = Math.min(30, 700 / (game.size * Math.sqrt(3)));
            hexWidth = Math.sqrt(3) * hexSide;
            hexHeight = 2 * hexSide;

            svg.innerHTML = '';
            const offsetX = hexWidth;
            const offsetY = hexHeight / 2;
            const totalW = game.size * hexWidth + hexWidth / 2 + offsetX * 2;
            const totalH = game.size * (hexHeight * 3 / 4) + hexHeight + offsetY * 2;
            svg.setAttribute('viewBox', `0 0 ${totalW} ${totalH}`);
            svg.setAttribute('width', '100%');
            svg.setAttribute('height', '100%');

            for (let r = 0; r < game.size; r++) {
                const x = 0 + offsetX;
                const y = r * (hexHeight * 3 / 4) + offsetY + hexHeight / 2;
                const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                rect.setAttribute('x', x - hexWidth / 2 - 15);
                rect.setAttribute('y', y - hexSide);
                rect.setAttribute('width', 15);
                rect.setAttribute('height', hexHeight);
                rect.classList.add('border-blue');
                svg.appendChild(rect);
            }
            for (let r = 0; r < game.size; r++) {
                const x = (game.size - 1) * hexWidth + (r % 2 ? hexWidth / 2 : 0) + offsetX;
                const y = r * (hexHeight * 3 / 4) + offsetY + hexHeight / 2;
                const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                rect.setAttribute('x', x + hexWidth / 2);
                rect.setAttribute('y', y - hexSide);
                rect.setAttribute('width', 15);
                rect.setAttribute('height', hexHeight);
                rect.classList.add('border-blue');
                svg.appendChild(rect);
            }
            for (let c = 0; c < game.size; c++) {
                const x = c * hexWidth + offsetX;
                const y = offsetY;
                const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                rect.setAttribute('x', x - hexWidth / 2);
                rect.setAttribute('y', y - hexSide - 15);
                rect.setAttribute('width', hexWidth);
                rect.setAttribute('height', 15);
                rect.classList.add('border-red');
                svg.appendChild(rect);
            }
            for (let c = 0; c < game.size; c++) {
                const x = c * hexWidth + ((game.size - 1) % 2 ? hexWidth / 2 : 0) + offsetX;
                const y = (game.size - 1) * (hexHeight * 3 / 4) + offsetY + hexHeight / 2;
                const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                rect.setAttribute('x', x - hexWidth / 2);
                rect.setAttribute('y', y + hexSide);
                rect.setAttribute('width', hexWidth);
                rect.setAttribute('height', 15);
                rect.classList.add('border-red');
                svg.appendChild(rect);
            }

            for (let r = 0; r < game.size; r++) {
                for (let c = 0; c < game.size; c++) {
                    const x = c * hexWidth + (r % 2 ? hexWidth / 2 : 0) + offsetX;
                    const y = r * (hexHeight * 3 / 4) + offsetY + hexHeight / 2;
                    const points = [
                        [x, y - hexSide],
                        [x + hexWidth / 2, y - hexSide / 2],
                        [x + hexWidth / 2, y + hexSide / 2],
                        [x, y + hexSide],
                        [x - hexWidth / 2, y + hexSide / 2],
                        [x - hexWidth / 2, y - hexSide / 2]
                    ].map(p => p.join(',')).join(' ');
                    const hex = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                    hex.setAttribute('points', points);
                    hex.classList.add('hex');
                    hex.dataset.row = r;
                    hex.dataset.col = c;
                    svg.appendChild(hex);

                    if (game.board[r][c] !== 0) {
                        const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                        circle.setAttribute('cx', x);
                        circle.setAttribute('cy', y);
                        circle.setAttribute('r', hexSide * 0.7);
                        circle.classList.add(game.board[r][c] === 1 ? 'blue-piece' : 'red-piece');
                        svg.appendChild(circle);
                    }
                }
            }
        }

        let game = null;
        let mode = 'pva';
        let playerColor = 1;
        let aiAlgo = 'minimax';
        let aiDepth = 3;

        document.getElementById('start-game').addEventListener('click', () => {
            const size = parseInt(document.getElementById('board-size').value);
            mode = document.getElementById('game-mode').value;
            aiAlgo = document.getElementById('ai-algo').value;
            aiDepth = parseInt(document.getElementById('ai-depth').value);
            playerColor = parseInt(document.getElementById('player-color').value);
            game = new HexGame(size);
            renderBoard(game, document.getElementById('hex-board'));
            document.getElementById('move-log').innerHTML = '';
            document.getElementById('status').textContent = 'Vez atual: Ciano (Esquerda para Direita)';
            document.getElementById('stats').textContent = 'Nós: 0\nTempo: 0ms';
            if (mode === 'ava' || (mode === 'pva' && game.currentPlayer !== playerColor)) {
                aiMove();
            }
        });

        document.getElementById('hex-board').addEventListener('click', (e) => {
            if (!game || game.winner || (mode === 'pva' && game.currentPlayer !== playerColor)) return;
            const target = e.target;
            if (target.tagName.toLowerCase() === 'polygon') {
                const r = parseInt(target.dataset.row);
                const c = parseInt(target.dataset.col);
                if (game.placePiece(r, c, game.currentPlayer)) {
                    renderBoard(game, document.getElementById('hex-board'));
                    logMove(game.moves.length, game.moves[game.moves.length - 1].player, r, c);
                    updateStatus();
                    if (game.winner) alert(`${game.winner === 1 ? 'Ciano' : 'Magenta'} venceu!`);
                    if (!game.winner && (mode === 'ava' || game.currentPlayer !== playerColor)) {
                        aiMove();
                    }
                }
            }
        });

        function aiMove() {
            if (!game || game.winner) return;
            document.getElementById('status').textContent = 'IA está pensando...';
            setTimeout(() => {
                const [r, c] = game.getBestMove(aiAlgo, aiDepth);
                game.placePiece(r, c, game.currentPlayer);
                renderBoard(game, document.getElementById('hex-board'));
                logMove(game.moves.length, game.moves[game.moves.length - 1].player, r, c);
                updateStatus();
                if (game.winner) alert(`${game.winner === 1 ? 'Ciano' : 'Magenta'} venceu!`);
                document.getElementById('stats').textContent = `Nós: ${game.nodesExplored}\nTempo: ${game.thinkingTime.toFixed(2)}ms`;
                if (mode === 'ava' && !game.winner) {
                    aiMove();
                }
            }, 100);
        }

        function logMove(num, player, r, c) {
            const li = document.createElement('li');
            li.textContent = `#${num}: ${player === 1 ? 'Ciano' : 'Magenta'} (${r},${c})`;
            document.getElementById('move-log').appendChild(li);
        }

        function updateStatus() {
            if (game.winner) {
                document.getElementById('status').textContent = `${game.winner === 1 ? 'Ciano' : 'Magenta'} venceu!`;
            } else {
                document.getElementById('status').textContent = `Vez atual: ${game.currentPlayer === 1 ? 'Ciano (Esquerda para Direita)' : 'Magenta (Cima para Baixo)'}`;
            }
        }
    </script>
</body>
</html>